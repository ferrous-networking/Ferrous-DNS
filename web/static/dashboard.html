<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¦€ Ferrous DNS - Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.13.5/dist/cdn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        [x-cloak] { display: none !important; }
        html, body { height: 100%; margin: 0; padding: 0; }
        body { display: flex; flex-direction: column; }
        main { flex: 1; overflow-y: auto; }
    </style>
</head>
<body class="bg-gray-50 h-full" x-data="dashboard()" x-init="init()">

<header class="bg-white shadow-sm border-b border-gray-200 sticky top-0 z-50">
    <div class="px-4 sm:px-6 lg:px-8 py-3 lg:py-4">
        <div class="flex items-center justify-between">
            <!-- Logo e TÃ­tulo -->
            <div class="flex items-center space-x-2 sm:space-x-3">
                <div class="text-2xl sm:text-3xl lg:text-4xl">ğŸ¦€</div>
                <div>
                    <h1 class="text-lg sm:text-xl lg:text-2xl font-bold text-gray-900">Ferrous DNS</h1>
                    <p class="text-xs sm:text-sm text-gray-500 hidden sm:block">Dashboard</p>
                </div>
            </div>

            <!-- Navigation - Responsive -->
            <div class="flex gap-1 sm:gap-2">
                <a href="/" class="px-2 sm:px-3 lg:px-4 py-1.5 sm:py-2 bg-blue-600 text-white text-xs sm:text-sm rounded-lg hover:bg-blue-700">
                    <span class="hidden sm:inline">ğŸ“Š Dashboard</span>
                    <span class="sm:hidden">ğŸ“Š</span>
                </a>
                <a href="/queries.html" class="px-2 sm:px-3 lg:px-4 py-1.5 sm:py-2 bg-gray-600 text-white text-xs sm:text-sm rounded-lg hover:bg-gray-700">
                    <span class="hidden sm:inline">ğŸ“ Query Log</span>
                    <span class="sm:hidden">ğŸ“</span>
                </a>
                <a href="/settings.html" class="px-2 sm:px-3 lg:px-4 py-1.5 sm:py-2 bg-gray-600 text-white text-xs sm:text-sm rounded-lg hover:bg-gray-700">
                    <span class="hidden sm:inline">âš™ï¸ Settings</span>
                    <span class="sm:hidden">âš™ï¸</span>
                </a>
            </div>
        </div>
    </div>
</header>

<main class="flex-1 px-3 sm:px-4 lg:px-8 py-4 sm:py-6 lg:py-8 overflow-y-auto">

    <!-- Stats Cards Row -->
    <div class="mb-3 sm:mb-4">
        <h2 class="text-base sm:text-lg font-semibold text-gray-700">ğŸ“Š EstatÃ­sticas das Ãšltimas 24 Horas</h2>
    </div>
    
    <!-- Stats Row 1: Main Stats -->
    <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 sm:gap-4 lg:gap-6 mb-6 sm:mb-8">
        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Total Queries</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold" x-text="stats.queries_total || 0">0</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Blocked</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-red-600" x-text="stats.queries_blocked || 0">0</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Clients</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-blue-600" x-text="stats.clients || 0">0</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Uptime</p>
            <p class="text-lg sm:text-xl lg:text-2xl font-bold text-green-600" x-text="uptime">0h</p>
        </div>
    </div>

    <!-- Stats Row 2: Cache Stats âœ¨ NEW! -->
    <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 sm:gap-4 lg:gap-6 mb-6 sm:mb-8">
        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Cache Hits</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-purple-600" x-text="cacheMetrics.total_hits || 0">0</p>
            <p class="text-xs text-purple-600 mt-1" x-text="(cacheMetrics.hit_rate || 0).toFixed(1) + '% hit rate'">0% hit rate</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Cache Misses</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-blue-600" x-text="cacheMetrics.total_misses || 0">0</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Cache Refreshes</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-yellow-600" x-text="cacheMetrics.total_refreshes || 0">0</p>
            <p class="text-xs text-yellow-600 mt-1" x-text="(cacheMetrics.refresh_rate || 0).toFixed(1) + '% of hits'">0% of hits</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Cache Entries</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-green-600" x-text="cacheMetrics.total_entries || 0">0</p>
        </div>
    </div>

    <!-- Stats Row 3: Performance Metrics -->
    <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 sm:gap-4 lg:gap-6 mb-6 sm:mb-8">
        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Cache Hit Rate</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-purple-600" x-text="stats.cache_hit_rate ? stats.cache_hit_rate.toFixed(1) + '%' : '0%'">0%</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">Avg Query Time</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-indigo-600" x-text="formatTime(stats.avg_query_time_ms || 0)">0 ms</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">âš¡ Cache Time</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-green-600" x-text="formatTime(stats.avg_cache_time_ms || 0)">0 ms</p>
        </div>

        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-3 sm:p-4 lg:p-6">
            <p class="text-xs sm:text-sm text-gray-600 mb-1">ğŸŒ Upstream Time</p>
            <p class="text-xl sm:text-2xl lg:text-3xl font-bold text-orange-600" x-text="formatTime(stats.avg_upstream_time_ms || 0)">0 ms</p>
        </div>
    </div>

    <!-- Queries over Time Chart -->
    <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-4 sm:p-6 mb-6 sm:mb-8" x-show="stats.queries_total > 0" x-cloak>
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-3 sm:mb-4 gap-2">
            <h2 class="text-lg sm:text-xl font-bold">ğŸ“ˆ Queries over Time</h2>
            <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded font-semibold self-start">Ãšltimas 24h</span>
        </div>
        <canvas id="timelineChart" class="w-full h-32 sm:h-40 lg:h-48"></canvas>
    </div>

    <!-- Empty state for no queries -->
    <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-4 sm:p-6 mb-6 sm:mb-8" x-show="stats.queries_total === 0" x-cloak>
        <h2 class="text-lg sm:text-xl font-bold mb-3 sm:mb-4">ğŸ“ˆ Queries over Time</h2>
        <div class="h-32 sm:h-40 lg:h-48 flex items-center justify-center bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
            <div class="text-center px-4">
                <p class="text-gray-400 text-base sm:text-lg mb-2">No queries yet</p>
                <p class="text-xs sm:text-sm text-gray-500 mb-2">Make a DNS query to see the timeline</p>
                <p class="text-xs text-gray-400">Example: <code class="bg-gray-100 px-2 py-1 rounded text-xs">dig @localhost -p 5353 google.com</code></p>
            </div>
        </div>
    </div>

    <!-- Pie Charts Row -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-6 mb-6 sm:mb-8">
        <!-- Query Types Pie Chart -->
        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-4 sm:p-6">
            <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-3 sm:mb-4 gap-2">
                <h2 class="text-lg sm:text-xl font-bold">ğŸ” Query Types</h2>
                <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded font-semibold self-start">Ãšltimas 24h</span>
            </div>
            <div x-show="stats.queries_total === 0" class="h-40 sm:h-48 flex items-center justify-center">
                <p class="text-gray-400 text-sm sm:text-base">No data yet</p>
            </div>
            <canvas id="queryTypesChart" x-show="stats.queries_total > 0" class="w-full h-40 sm:h-48"></canvas>
        </div>

        <!-- Cache vs Upstream Pie Chart -->
        <div class="bg-white rounded-lg sm:rounded-xl shadow-sm p-4 sm:p-6">
            <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-3 sm:mb-4 gap-2">
                <h2 class="text-lg sm:text-xl font-bold">âš¡ Response Source</h2>
                <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded font-semibold self-start">Ãšltimas 24h</span>
            </div>
            <div x-show="stats.queries_total === 0" class="h-40 sm:h-48 flex items-center justify-center">
                <p class="text-gray-400 text-sm sm:text-base">No data yet</p>
            </div>
            <canvas id="cacheSourceChart" x-show="stats.queries_total > 0" class="w-full h-40 sm:h-48"></canvas>
        </div>
    </div>

</main>

<script>
    function dashboard() {
        return {
            stats: {
                queries_total: 0,
                queries_blocked: 0,
                clients: 0,
                uptime: 0,
                cache_hit_rate: 0,
                avg_query_time_ms: 0,
                avg_cache_time_ms: 0,
                avg_upstream_time_ms: 0,
            },
            queriesChart: null,
            timelineChart: null,
            queryTypesChart: null,
            cacheSourceChart: null,
            timelineData: {
                total: new Array(24).fill(0),
                blocked: new Array(24).fill(0)
            },
            upstreamServers: [],
            queryTypes: {},
            cacheStats: { cache: 0, upstream: 0 },
            cacheMetrics: {
                total_entries: 0,
                total_hits: 0,
                total_misses: 0,
                total_refreshes: 0,
                hit_rate: 0,
                refresh_rate: 0
            },
            dnssecEnabled: false,
            dnssecStats: {
                total: 0,
                DS: 0,
                DNSKEY: 0,
                RRSIG: 0,
                NSEC: 0,
                NSEC3: 0,
                NSEC3PARAM: 0,
                CDS: 0,
                CDNSKEY: 0
            },
            dnssecTypes: ['DS', 'DNSKEY', 'RRSIG', 'NSEC', 'NSEC3', 'NSEC3PARAM', 'CDS', 'CDNSKEY'],
            serverHostname: 'localhost',  // Server hostname

            get uptime() {
                const hours = Math.floor(this.stats.uptime / 3600);
                const mins = Math.floor((this.stats.uptime % 3600) / 60);
                return `${hours}h ${mins}m`;
            },

            get dnssecPercentage() {
                if (this.stats.queries_total === 0) return '0%';
                return ((this.dnssecStats.total / this.stats.queries_total) * 100).toFixed(1) + '%';
            },

            async init() {
                console.log('Dashboard initializing...');
                
                // Load config first to check DNSSEC
                await this.loadConfig();
                await this.loadHostname();
                
                // Load all data
                await this.loadStats();
                await this.loadQueryTypes();
                await this.loadCacheStats();
                await this.loadCacheMetrics();
                
                // Calculate DNSSEC stats if enabled
                if (this.dnssecEnabled) {
                    await this.loadDnssecStats();
                }
                
                console.log('Stats loaded:', this.stats);
                console.log('Query types:', this.queryTypes);
                console.log('Cache stats:', this.cacheStats);
                console.log('Cache metrics:', this.cacheMetrics);
                console.log('DNSSEC enabled:', this.dnssecEnabled);
                console.log('DNSSEC stats:', this.dnssecStats);
                console.log('Server hostname:', this.serverHostname);
                
                // Now initialize charts with the loaded data
                this.initCharts();
                
                // Auto-refresh every 1 second
                setInterval(() => this.loadStats(), 1000);
                setInterval(() => {
                    this.loadQueryTypes();
                    this.loadCacheStats();
                    this.loadCacheMetrics();
                    if (this.dnssecEnabled) {
                        this.loadDnssecStats();
                    }
                    this.updateTimelineFromCurrentStats(); // Update timeline with current data
                    this.updateCharts();
                }, 1000);
                
                // Refresh full timeline data every 5 minutes
                setInterval(() => this.loadTimelineData(), 300000);
            },

            async loadConfig() {
                try {
                    const res = await fetch('/api/config');
                    const config = await res.json();
                    this.dnssecEnabled = config.dns.dnssec_enabled;
                    console.log('DNSSEC enabled:', this.dnssecEnabled);
                } catch (error) {
                    console.error('Error loading config:', error);
                }
            },

            async loadHostname() {
                try {
                    const res = await fetch('/api/hostname');
                    const data = await res.json();
                    this.serverHostname = data.hostname;
                    console.log('Server hostname:', this.serverHostname);
                } catch (error) {
                    console.error('Error loading hostname:', error);
                }
            },

            async loadDnssecStats() {
                try {
                    const res = await fetch('/api/queries');
                    const queries = await res.json();
                    
                    // Reset counts
                    this.dnssecStats = {
                        total: 0,
                        DS: 0,
                        DNSKEY: 0,
                        RRSIG: 0,
                        NSEC: 0,
                        NSEC3: 0,
                        NSEC3PARAM: 0,
                        CDS: 0,
                        CDNSKEY: 0
                    };
                    
                    // Count DNSSEC queries
                    queries.forEach(q => {
                        if (this.dnssecTypes.includes(q.type)) {
                            this.dnssecStats.total++;
                            if (this.dnssecStats[q.type] !== undefined) {
                                this.dnssecStats[q.type]++;
                            }
                        }
                    });
                    
                    console.log('DNSSEC stats calculated:', this.dnssecStats);
                } catch (error) {
                    console.error('Error loading DNSSEC stats:', error);
                }
            },

            async loadStats() {
                try {
                    console.log('Fetching /api/stats...');
                    const res = await fetch('/api/stats');
                    if (!res.ok) {
                        console.error('Stats API error:', res.status);
                        return;
                    }
                    this.stats = await res.json();
                    console.log('Stats received:', this.stats);
                } catch (error) {
                    console.error('Error loading stats:', error);
                }
            },

            async loadQueryTypes() {
                try {
                    console.log('Fetching /api/queries for types...');
                    const res = await fetch('/api/queries');
                    if (!res.ok) {
                        console.error('Queries API error:', res.status);
                        return;
                    }
                    const queries = await res.json();
                    console.log('Queries received:', queries.length, 'queries');
                    
                    // Count query types
                    this.queryTypes = {};
                    queries.forEach(q => {
                        this.queryTypes[q.type] = (this.queryTypes[q.type] || 0) + 1;
                    });
                    console.log('Query types counted:', this.queryTypes);
                } catch (error) {
                    console.error('Error loading query types:', error);
                }
            },

            async loadCacheStats() {
                try {
                    console.log('Fetching /api/queries for cache stats...');
                    const res = await fetch('/api/queries');
                    if (!res.ok) {
                        console.error('Queries API error:', res.status);
                        return;
                    }
                    const queries = await res.json();
                    
                    // Count cache vs upstream
                    let cache = 0, upstream = 0;
                    queries.forEach(q => {
                        if (q.blocked) return; // Skip blocked
                        if (q.cache_hit) cache++;
                        else upstream++;
                    });
                    
                    this.cacheStats = { cache, upstream };
                    console.log('Cache stats:', this.cacheStats);
                } catch (error) {
                    console.error('Error loading cache stats:', error);
                }
            },

            async loadCacheMetrics() {
                try {
                    console.log('Fetching /api/cache/metrics...');
                    const res = await fetch('/api/cache/metrics');
                    if (!res.ok) {
                        console.error('Cache metrics API error:', res.status);
                        return;
                    }
                    const metrics = await res.json();
                    console.log('Cache metrics received:', metrics);
                    
                    // Map to dashboard structure
                    this.cacheMetrics = {
                        total_hits: metrics.hits,
                        total_misses: metrics.misses,
                        total_refreshes: metrics.optimistic_refreshes,
                        total_entries: metrics.total_entries,
                        hit_rate: metrics.hit_rate,
                        refresh_rate: metrics.hits > 0 
                            ? (metrics.optimistic_refreshes / metrics.hits * 100) 
                            : 0
                    };
                    
                    console.log('Mapped cache metrics:', this.cacheMetrics);
                } catch (error) {
                    console.error('Error loading cache metrics:', error);
                }
            },

            initCharts() {
                console.log('Initializing charts...');
                
                // Timeline chart - queries over time (last 24h)
                const ctxTimeline = document.getElementById('timelineChart');
                if (ctxTimeline && ctxTimeline.offsetParent !== null) {
                    console.log('Creating timeline chart');
                    this.timelineChart = new Chart(ctxTimeline.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: this.generateTimeLabels(),
                            datasets: [{
                                label: 'Total Queries',
                                data: new Array(24).fill(0),
                                borderColor: 'rgb(59, 130, 246)',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                fill: true,
                                tension: 0.4
                            }, {
                                label: 'Blocked',
                                data: new Array(24).fill(0),
                                borderColor: 'rgb(239, 68, 68)',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return context.dataset.label + ': ' + context.parsed.y + ' queries';
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Last 24 Hours'
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Queries'
                                    },
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                    
                    // Load initial timeline data
                    this.loadTimelineData();
                }
                
                // Query types pie chart - only if there's data
                if (Object.keys(this.queryTypes).length > 0) {
                    const ctx2 = document.getElementById('queryTypesChart');
                    if (ctx2 && ctx2.offsetParent !== null) {  // Check if visible
                        console.log('Creating query types chart');
                        this.queryTypesChart = new Chart(ctx2.getContext('2d'), {
                            type: 'doughnut',
                            data: {
                                labels: Object.keys(this.queryTypes),
                                datasets: [{
                                    data: Object.values(this.queryTypes),
                                    backgroundColor: [
                                        'rgb(59, 130, 246)',
                                        'rgb(147, 51, 234)',
                                        'rgb(34, 197, 94)',
                                        'rgb(251, 191, 36)',
                                        'rgb(239, 68, 68)',
                                        'rgb(156, 163, 175)'
                                    ]
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: true,
                                plugins: {
                                    legend: {
                                        position: 'right',
                                    }
                                }
                            }
                        });
                    }
                }

                // Cache vs Upstream pie chart - only if there's data
                if (this.cacheStats.cache > 0 || this.cacheStats.upstream > 0) {
                    const ctx3 = document.getElementById('cacheSourceChart');
                    if (ctx3 && ctx3.offsetParent !== null) {  // Check if visible
                        console.log('Creating cache source chart');
                        this.cacheSourceChart = new Chart(ctx3.getContext('2d'), {
                            type: 'doughnut',
                            data: {
                                labels: ['âš¡ Cache', 'ğŸŒ Upstream'],
                                datasets: [{
                                    data: [this.cacheStats.cache, this.cacheStats.upstream],
                                    backgroundColor: [
                                        'rgb(168, 85, 247)',
                                        'rgb(59, 130, 246)'
                                    ]
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: true,
                                plugins: {
                                    legend: {
                                        position: 'right',
                                    }
                                }
                            }
                        });
                    }
                }

                console.log('Charts initialized:', {
                    timeline: !!this.timelineChart,
                    queryTypes: !!this.queryTypesChart,
                    cacheSource: !!this.cacheSourceChart
                });
            },

            async updateCharts() {
                console.log('Updating charts...');
                
                // Update query types chart
                const ctx2 = document.getElementById('queryTypesChart');
                if (this.queryTypesChart && ctx2 && Object.keys(this.queryTypes).length > 0) {
                    console.log('Updating query types chart with:', this.queryTypes);
                    this.queryTypesChart.data.labels = Object.keys(this.queryTypes);
                    this.queryTypesChart.data.datasets[0].data = Object.values(this.queryTypes);
                    this.queryTypesChart.update('none');
                } else {
                    console.log('Skipping query types chart update (no data or chart not ready)');
                }

                // Update cache/upstream chart
                const ctx3 = document.getElementById('cacheSourceChart');
                if (this.cacheSourceChart && ctx3 && (this.cacheStats.cache > 0 || this.cacheStats.upstream > 0)) {
                    console.log('Updating cache source chart with:', this.cacheStats);
                    this.cacheSourceChart.data.datasets[0].data = [
                        this.cacheStats.cache,
                        this.cacheStats.upstream
                    ];
                    this.cacheSourceChart.update('none');
                } else {
                    console.log('Skipping cache source chart update (no data or chart not ready)');
                }
            },

            formatTime(ms) {
                if (!ms || ms === 0) return '0 ms';
                
                // Se for microsegundos (< 1000)
                if (ms < 1000) {
                    const rounded = Math.round(ms);
                    return `${rounded} Âµs`;
                }
                
                // Se for millisegundos, arredondar para 1 casa decimal
                const msValue = (ms / 1000).toFixed(1);
                return `${msValue} ms`;
            },

            generateTimeLabels() {
                const labels = [];
                const now = new Date();
                for (let i = 23; i >= 0; i--) {
                    const hour = new Date(now.getTime() - i * 60 * 60 * 1000);
                    labels.push(hour.getHours() + 'h');
                }
                return labels;
            },

            async loadTimelineData() {
                try {
                    const res = await fetch('/api/queries/timeline');
                    const data = await res.json();
                    
                    if (data && data.length > 0) {
                        // Data comes as array of {hour, total, blocked}
                        this.timelineData.total = data.map(d => d.total || 0);
                        this.timelineData.blocked = data.map(d => d.blocked || 0);
                        
                        if (this.timelineChart) {
                            this.timelineChart.data.datasets[0].data = this.timelineData.total;
                            this.timelineChart.data.datasets[1].data = this.timelineData.blocked;
                            this.timelineChart.update('none');
                        }
                    }
                } catch (error) {
                    console.error('Error loading timeline data:', error);
                    // Use accumulated data from current stats as fallback
                    this.updateTimelineFromCurrentStats();
                }
            },

            updateTimelineFromCurrentStats() {
                // Fallback: show current hour's stats
                const currentHourIndex = 23; // Last hour in the 24h array
                this.timelineData.total[currentHourIndex] = this.stats.queries_total || 0;
                this.timelineData.blocked[currentHourIndex] = this.stats.queries_blocked || 0;
                
                if (this.timelineChart) {
                    this.timelineChart.data.datasets[0].data = this.timelineData.total;
                    this.timelineChart.data.datasets[1].data = this.timelineData.blocked;
                    this.timelineChart.update('none');
                }
            },

            getResponseTimeColor(time) {
                if (!time) return 'text-gray-400';
                if (time < 1000) return 'text-green-600 font-semibold';  // Âµs
                if (time < 10000) return 'text-yellow-600 font-semibold'; // < 10ms
                if (time < 50000) return 'text-orange-600 font-semibold'; // < 50ms
                return 'text-red-600 font-semibold'; // > 50ms
            }
        }
    }
</script>
</body>
</html>
